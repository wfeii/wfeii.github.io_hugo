---
title: 重构原则
date: 2016-08-30 21:27:50
categories:
 - 重构
tags:
 - 重构
toc: true
toc_label: "重构原则"
---

![重构原则](https://github.com/wfeii/wfeii.github.io_raw_important/blob/master/%E9%87%8D%E6%9E%84-%E6%97%A2%E6%9C%89%E4%BB%A3%E7%A0%81%E7%9A%84%E8%AE%BE%E8%AE%A1/%E9%87%8D%E6%9E%842-%E5%8E%9F%E5%88%99.png?raw=true){: .align-center}  

## **何谓重构**  

> 重构 ： 对软件内部结构的一种调整，目的是在不改变软件可观察性的前提下，提高其可理解性，降低其修改的成本 。  

其实重构是在不改变代码的功能基础上，提高代码的可读性，提高代码的扩展性。  

**两顶帽子**  
添加新功能，重构。在软件开发中，两种情况不断变换，首先可能尝试添加新功能，其次意识到： 结构调整一下，功能更容易添加。于是就做一次重构，结构调整好之后，继续添加新功能，发现问题又会重构，就这样迭代。  

> Notice: 在做新功能时候，不能只为添加新功能而添加新功能，需要保持代码的结构性，易读性。

## **为何重构**  

- **重构改进软件设计**  

  没有重构，程序的设计可能逐渐的不可控，程序的机构性会遭到破坏，代码的可读性也会降低。**代码机构的流失是累积的，越难看出代码的设计意图，就越难保护其设计，代码的设计腐败的越快，代码的可控性就严重降低。** 通过重构可以让所有的代码回归的到本身应该在的位置。重构帮助代码维持该有的设计。
<br />

- **重构使软件更容易理解**  

  引用一句话，我觉得很恰当
  > 连傻子都能写出让机器机能运行的代码，但优秀的代码却是能让人理解的。

  程序设计很大程度上是跟计算机交流，但是除了跟计算机交流之外最重要的交流对象是人，**写的连鬼都看不懂的代码，让人看个鬼，过了一段时间自己都看不懂自己写的代码就真是见了鬼了（这种情况比见到鬼容易多了，哈哈哈）**。通过重构可以保证代码的可读性，而且通过重构可以更好的理解不熟悉的代码。   
  重构的开始可能只提留在细枝末节上。随着代码的简化，我们可以看到一些一些一切看不到的设计的层面的问题，有前辈把“早期重构”描述为“擦掉窗户上的污垢，使你看的更远”。如果没有重构，达不到这种层次。
<br />

- **重构帮助找到bug**  

  对于代码的理解，可以帮助找到bug。通过重构更深入的理解代码的结构、行为，从而找到隐藏很深的bug。  

  > 我不是一个伟大的程序员，我只是个有着一些优秀习惯的程序员
  > \- Kent Beck  

- **提高编程速度**  

良好的设计是快速开发的根本，拥有良好的设计才能快速的开发。如果没有良好的设计，或许一段时间内你的进展迅速，但恶劣的设计很快就让你的速度慢下来。会有大量的时间去调试，理解代码的逻辑，寻找重复的代码。最终坏的代码带来大的灾难。  
重构一定程度提高了代码的扩展性，保持了代码良好的结构，添加新功能也就容易点。   
<br />

## **何时重构**  

> 你不应该为了重构而重构，你之所以重构，是因为你想做别的什么事，而重构可以帮助你把事情做好。  

**三次法则**
> 事不过三，三则重构    

出现了代码重复，说明需要重构了。

**添加新功能时重构**  
- 通过重构可以更好的理解代码的逻辑，理清代码的结构，更好的添加新功能。
- 代码的设计无法帮助我们轻松的添加想要的功能时候，就需要重构来更好的添加新功能。  

**修复bug时候**  
收到bug但是不能一眼看出bug的问题，很大程度说明代码的逻辑不够清楚，需要重构了。

**复审代码时重构**    
复审者提出好的建议，然后一起探讨一些修改能否通过重构轻松实现，如果是这样，一起着手修改，这样保证了代码的质量  

**为什么重构有用**  
程序有两方面的价值
- 今天可以为你做什么
- 明天可以为你做什么
我们都只关注今天想要程序做什么。修复bug,添加新功能，我们都是为了让程序能力更强，让它今天更有价值。如果为了今天的工作不择手段，导致不可能在明天完成任务，最终还是失败。重构是摆脱这个困境的道路。**如果发现昨天的决定已经不能适应今天的情况，放心改变这个决定就是，然后就可以完成今天的决定，日复一日。**

是什么程序难以修改    
- 难以阅读的代码，难以修改
- 逻辑重复的代码，难以修改
- 添加新行为时需要修改已有的代码结构，难以修改
- 带有复杂逻辑的程序，难以修改

## **重构的难题**  

**数据库**
- 大多数商用程序都与它们背后的数据库耦合在一起，导致了数据结构难以修改之一
- 数据迁移，非常小心地将系统分层，将数据结构和对象模型间的一类降至最低，但数据库结构的改变还是会让人不得不迁移所有的数据
<br />

**修改接口**  
- 对于未发布的接口 如果接口的调用者都在自己的控制下，修改接口不会造成影响
- 已发布的接口 接口已经发布了，那么就需要维护新旧接口，保证调用者正常运行，对于旧接口可以通过新接口来实现。

> 不要过早发布接口。

**难以通过重构手法完成设计的改动**  

考虑候选设计方案时，想想将某个方案改为另一设计的难度又多大？如果看上去简短，就不必担心选择是否得当，就可以先简单实现。如果预先不到重构方法，就需要在设计上投入更多力气。
<br />

**何时不该重构**

- 重写，有时既有代码的是在太混乱，重构不如重写一个简单。重写的一个信号就是现有代码不能正常的运行。
- 项目已经接近尾声，没有时间来重构。
<br />

## **重构与设计**

- 一种观点，重构代替预先设计，只是按照最开始的想法编程，让代码有效运行，然后再重构成型，极限编程的支持者也支持这种方式。虽然这个方式也能收到很好的效果，但不是最有效的方式。往往可能会推到重做。
- 一种观点是检验各种想法，然后得到一个可以被接受的解决方案，然后再开始编程，最后再使用重构。这种方式简化了设计。

> 过度的设计往往是不需要的，每个可能变化都提高灵活性，不仅工作量大，而且整个系统的复杂度大大的增加了。可是这些灵活性在后面的开发中可能完全用不到。先简单的实现，然后需要的时候通过重构来达到灵活性。

<br/>

## **重构与性能**  

> 虽然重构**可能**使软件运行更慢，但是它也可以使软件的优化更容易。

三种编写出快速的方法：
- 时间预算法，分解设计时做好预算，每个组件预定分配一定资源。每个组件不能超出自己的预算。这种方式只适用于实时性的系统。
- 持续关注法，这种方式要求程序员在任何时间做任何事时，都要保持系统的高性能。这种方式如果为了提高性能，通常会使程序难以维护，进而减缓开发的速度。然后性能改善一但被分散程序的各个角落，每次改善并不能去除实际问题。
- 性能提升法，如果一视同仁地优化所有代码，往往90%的优化都是徒劳的。此方法使用工具找到性能热点，然后重构保证程序正常运行，并优化性能，一单发现不能提高性能，直接回退。然后继续的"发现热点，去除热点"。

良好的程序首先可以保证开速地增加功能，有更多的时间优化，其次良好的程序，进行调优时候又较细的粒度，从而更容易调优。
